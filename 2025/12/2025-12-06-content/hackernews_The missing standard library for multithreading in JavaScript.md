---
source: hackernews
title: The missing standard library for multithreading in JavaScript
url: https://github.com/W4G1/multithreading
date: 2025-12-06
---

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FW4G1%2Fmultithreading)

Appearance settings

* Platform

  + [GitHub Copilot

    Write better code with AI](https://github.com/features/copilot)
  + [GitHub Spark
    New

    Build and deploy intelligent apps](https://github.com/features/spark)
  + [GitHub Models
    New

    Manage and compare prompts](https://github.com/features/models)
  + [GitHub Advanced Security

    Find and fix vulnerabilities](https://github.com/security/advanced-security)
  + [Actions

    Automate any workflow](https://github.com/features/actions)

  + [Codespaces

    Instant dev environments](https://github.com/features/codespaces)
  + [Issues

    Plan and track work](https://github.com/features/issues)
  + [Code Review

    Manage code changes](https://github.com/features/code-review)
  + [Discussions

    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search

    Find more, search less](https://github.com/features/code-search)

  Explore
  + [Why GitHub](https://github.com/why-github)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)

  Integrations
  + [GitHub Marketplace](https://github.com/marketplace)
  + [MCP Registry](https://github.com/mcp)

  [View all features](https://github.com/features)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)

  By use case
  + [App Modernization](/solutions/use-case/app-modernization)
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles?topic=ai)
  + [DevOps](/resources/articles?topic=devops)
  + [Security](/resources/articles?topic=security)
  + [Software Development](/resources/articles?topic=software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [Events & Webinars](https://github.com/resources/events)
  + [Ebooks & Whitepapers](https://github.com/resources/whitepapers)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://github.com/partners)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors

    Fund open source developers](/sponsors)

  + [The ReadME Project

    GitHub community articles](https://github.com/readme)

  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform

    AI-powered developer platform](/enterprise)

  Available add-ons
  + [GitHub Advanced Security

    Enterprise-grade security features](https://github.com/security/advanced-security)
  + [Copilot for business

    Enterprise-grade AI features](/features/copilot/copilot-business)
  + [Premium Support

    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

[ ]
Include my email address so I can be contacted

Cancel
 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Cancel
 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FW4G1%2Fmultithreading)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E&source=header-repo&source_repo=W4G1%2Fmultithreading)

Appearance settings

Resetting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[W4G1](/W4G1)
/
**[multithreading](/W4G1/multithreading)**
Public

* [Notifications](/login?return_to=%2FW4G1%2Fmultithreading) You must be signed in to change notification settings
* [Fork
  12](/login?return_to=%2FW4G1%2Fmultithreading)
* [Star
   567](/login?return_to=%2FW4G1%2Fmultithreading)

The missing standard library for multithreading in JavaScript (Works in Node.js, Deno, Bun, Web browser)

### License

[MIT license](/W4G1/multithreading/blob/main/LICENSE.md)

[567
stars](/W4G1/multithreading/stargazers) [12
forks](/W4G1/multithreading/forks) [Branches](/W4G1/multithreading/branches) [Tags](/W4G1/multithreading/tags) [Activity](/W4G1/multithreading/activity)

[Star](/login?return_to=%2FW4G1%2Fmultithreading)

[Notifications](/login?return_to=%2FW4G1%2Fmultithreading) You must be signed in to change notification settings

* [Code](/W4G1/multithreading)
* [Issues
  1](/W4G1/multithreading/issues)
* [Pull requests
  0](/W4G1/multithreading/pulls)
* [Discussions](/W4G1/multithreading/discussions)
* [Actions](/W4G1/multithreading/actions)
* [Projects
  0](/W4G1/multithreading/projects)
* [Security

  ### Uh oh!

  There was an error while loading. Please reload this page.](/W4G1/multithreading/security)
* [Insights](/W4G1/multithreading/pulse)

Additional navigation options

* [Code](/W4G1/multithreading)
* [Issues](/W4G1/multithreading/issues)
* [Pull requests](/W4G1/multithreading/pulls)
* [Discussions](/W4G1/multithreading/discussions)
* [Actions](/W4G1/multithreading/actions)
* [Projects](/W4G1/multithreading/projects)
* [Security](/W4G1/multithreading/security)
* [Insights](/W4G1/multithreading/pulse)

# W4G1/multithreading

main

[Branches](/W4G1/multithreading/branches)[Tags](/W4G1/multithreading/tags)

Go to file

Code

Open more actions menu

## Folders and files

| Name | | Name | Last commit message | Last commit date |
| --- | --- | --- | --- | --- |
| Latest commit   History[81 Commits](/W4G1/multithreading/commits/main/) | | |
| [lib](/W4G1/multithreading/tree/main/lib "lib") | | [lib](/W4G1/multithreading/tree/main/lib "lib") |  |  |
| [scripts](/W4G1/multithreading/tree/main/scripts "scripts") | | [scripts](/W4G1/multithreading/tree/main/scripts "scripts") |  |  |
| [test](/W4G1/multithreading/tree/main/test "test") | | [test](/W4G1/multithreading/tree/main/test "test") |  |  |
| [.gitignore](/W4G1/multithreading/blob/main/.gitignore ".gitignore") | | [.gitignore](/W4G1/multithreading/blob/main/.gitignore ".gitignore") |  |  |
| [LICENSE.md](/W4G1/multithreading/blob/main/LICENSE.md "LICENSE.md") | | [LICENSE.md](/W4G1/multithreading/blob/main/LICENSE.md "LICENSE.md") |  |  |
| [README.md](/W4G1/multithreading/blob/main/README.md "README.md") | | [README.md](/W4G1/multithreading/blob/main/README.md "README.md") |  |  |
| [deno.jsonc](/W4G1/multithreading/blob/main/deno.jsonc "deno.jsonc") | | [deno.jsonc](/W4G1/multithreading/blob/main/deno.jsonc "deno.jsonc") |  |  |
| [deno.lock](/W4G1/multithreading/blob/main/deno.lock "deno.lock") | | [deno.lock](/W4G1/multithreading/blob/main/deno.lock "deno.lock") |  |  |
| View all files | | |

## Repository files navigation

* README
* MIT license

[![Logo](https://private-user-images.githubusercontent.com/38042257/523092640-e7750ae6-3acd-4c81-9417-3979f51535f3.png?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NjUwMDk4MjksIm5iZiI6MTc2NTAwOTUyOSwicGF0aCI6Ii8zODA0MjI1Ny81MjMwOTI2NDAtZTc3NTBhZTYtM2FjZC00YzgxLTk0MTctMzk3OWY1MTUzNWYzLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTEyMDYlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUxMjA2VDA4MjUyOVomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPWM2MWQ5Zjg5NWU1MzRiMzEwZjM3NThkOTQzYWVjYzVkOTI4ODkwMzQyNWZiNjdmNTYwNzc1MmIxYmUxZWIxMDcmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.qNThNtatZBnKMxYxfDoJQhJCTliUvs9lcUSAgQVu0Y8)](https://private-user-images.githubusercontent.com/38042257/523092640-e7750ae6-3acd-4c81-9417-3979f51535f3.png?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NjUwMDk4MjksIm5iZiI6MTc2NTAwOTUyOSwicGF0aCI6Ii8zODA0MjI1Ny81MjMwOTI2NDAtZTc3NTBhZTYtM2FjZC00YzgxLTk0MTctMzk3OWY1MTUzNWYzLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTEyMDYlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUxMjA2VDA4MjUyOVomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPWM2MWQ5Zjg5NWU1MzRiMzEwZjM3NThkOTQzYWVjYzVkOTI4ODkwMzQyNWZiNjdmNTYwNzc1MmIxYmUxZWIxMDcmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.qNThNtatZBnKMxYxfDoJQhJCTliUvs9lcUSAgQVu0Y8)

[![License](https://camo.githubusercontent.com/0f2f1b81c52c18193dbc43123d819500b85c952273a3d1d6f265f93ae524c71d/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f573447312f6d756c7469746872656164696e67)](https://github.com/W4G1/multithreading/blob/main/LICENSE.md)
[![Downloads](https://camo.githubusercontent.com/1e90de1d47248ab4c4255dac578c47550be035ea1fda1977bc961ed940cac7ce/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f64772f6d756c7469746872656164696e673f636f6c6f723d253233383935364646)](https://www.npmjs.com/package/multithreading)
[![NPM version](https://camo.githubusercontent.com/5561e74e1364b345569ca1eb2f6324ee368a05911ae2a603484a27d2ddf837a5/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f6d756c7469746872656164696e67)](https://www.npmjs.com/package/multithreading?activeTab=versions)
[![GitHub Repo stars](https://camo.githubusercontent.com/6250c9873c1acbf5b0d4e369a59f70a8f4c543227b141845cadfa7d9fbf11893/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f73746172732f573447312f6d756c7469746872656164696e673f6c6f676f3d676974687562266c6162656c3d53746172266c6162656c436f6c6f723d726762283236253243253230333025324325323033352926636f6c6f723d7267622831332532432532303137253243253230323329)](https://github.com/W4G1/multithreading)

# Multithreading.js

**Multithreading** is a TypeScript library that brings robust, Rust-inspired concurrency primitives to the JavaScript ecosystem. It provides a thread-pool architecture, strict memory safety semantics, and synchronization primitives like Mutexes, Read-Write Locks, and Condition Variables.

This library is designed to abstract away the complexity of managing `WebWorkers`, serialization, and `SharedArrayBuffer` complexities, allowing developers to write multi-threaded code that looks and feels like standard asynchronous JavaScript.

## Installation

```
npm install multithreading
```

## Core Concepts

JavaScript is traditionally single-threaded. To achieve true parallelism, this library uses Web Workers. However, unlike standard Workers, this library offers:

1. **Managed Worker Pool**: Automatically manages a pool of threads based on hardware concurrency.
2. **Shared Memory Primitives**: Tools to safely share state between threads without race conditions.
3. **Scoped Imports**: Support for importing external modules and relative files directly within worker tasks.
4. **Move Semantics**: Explicit data ownership transfer to prevent cloning overhead.

## Quick Start

The entry point for most operations is the `spawn` function. This submits a task to the thread pool and returns a handle to await the result.

```
import { spawn } from "multithreading";

// Spawn a task on a background thread
const handle = spawn(() => {
  // This code runs in a separate worker
  const result = Math.random();
  return result;
});

// Wait for the result
const result = await handle.join();

if (result.ok) {
  console.log("Result:", result.value); // 0.6378467071314606
} else {
  console.error("Worker error:", result.error);
}
```

---

## Passing Data: The `move()` Function

Because Web Workers run in a completely isolated context, functions passed to `spawn` cannot capture variables from their outer scope. If you attempt to use a variable inside the worker that was defined outside of it, the code will fail.

To get data from your main thread into the worker, you have to use the `move()` function.

The `move` function accepts variadic arguments. These arguments are passed to the worker function in the order they were provided. Despite the name, `move` handles data in two ways:

1. **Transferable Objects (e.g., `ArrayBuffer`, `Uint32Array`):** These are "moved" (zero-copy). Ownership transfers to the worker, and the original becomes unusable in the main thread.
2. **Non-Transferable Objects (e.g., JSON, numbers, strings):** These are cloned via structured cloning. They remain usable in the main thread.

```
import { spawn, move } from "multithreading";

// Will be transfered
const largeData = new Uint8Array(1024 * 1024 * 10); // 10MB
// Will be cloned
const metaData = { id: 1 };

// We pass arguments as a comma-separated list.
const handle = spawn(move(largeData, metaData), (data, meta) => {
  console.log("Processing ID:", meta.id);
  return data.byteLength;
});

await handle.join();
```

---

## SharedJsonBuffer: Sharing Complex Objects

`SharedJsonBuffer` enables Mutex-protected shared memory for JSON objects, eliminating the overhead of `postMessage` data copying. Unlike standard buffers, it handles serialization automatically. It supports partial updates, re-serializing only changed bytes rather than the entire object tree for high-performance state synchronization.

```
import { move, Mutex, SharedJsonBuffer, spawn } from "multithreading";

const sharedState = new Mutex(new SharedJsonBuffer({
  score: 0,
  players: ["Main Thread"],
  level: {
    id: 1,
    title: "Start",
  },
}));

await spawn(move(sharedState), async (lock) => {
  using guard = await lock.acquire();

  const state = guard.value;

  console.log(`Current Score: ${state.score}`);

  // Modify the data
  state.score += 100;
  state.players.push("Worker1");

  // End of scope: Lock is automatically released here
}).join();

// Verify on main thread
using guard = await sharedState.acquire();

console.log(guard.value); // { score: 100, players: ["Main Thread", "Worker1"], ... }
```

---

## Synchronization Primitives

When multiple threads access shared memory (via `SharedArrayBuffer`), race conditions occur. This library provides primitives to synchronize access safely.

**Best Practice:** It is highly recommended to use the asynchronous methods (e.g., `acquire`, `read`, `write`, `wait`) rather than their synchronous counterparts. Synchronous blocking halts the entire Worker thread, potentially pausing other tasks sharing that worker.

### 1. Mutex (Mutual Exclusion)

A `Mutex` ensures that only one thread can access a specific piece of data at a time.

#### Option A: Automatic Management (Recommended)

This library leverages the [Explicit Resource Management](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/using) proposal (`using` keyword). When you acquire a lock, it returns a guard. When that guard goes out of scope, the lock is automatically released.

```
import { spawn, move, Mutex } from "multithreading";

const buffer = new SharedArrayBuffer(4);
const counterMutex = new Mutex(new Int32Array(buffer));

spawn(move(counterMutex), async (mutex) => {
  // 'using' automatically calls dispose() at the end of the scope
  using guard = await mutex.acquire();

  guard.value[0]++;

  // End of scope: Lock is automatically released here
});
```

#### Option B: Manual Management (Bun / Standard JS)

If you are using **Bun** (which doesn't natively support `using` and uses a transpiler which is incompatible with this library) or prefer standard JavaScript syntax, you must manually release the lock using `drop()`. Always use a `try...finally` block to ensure the lock is released even if an error occurs.

```
import { spawn, move, Mutex } from "multithreading";

const buffer = new SharedArrayBuffer(4);
const counterMutex = new Mutex(new Int32Array(buffer));

spawn(move(counterMutex), async (mutex) => {
  // Note that we have to import drop here, otherwise it wouldn't be available
  const { drop } = await import("multithreading");

  // 1. Acquire the lock manually
  const guard = await mutex.acquire();

  try {
    // 2. Critical Section
    guard.value[0]++;
  } finally {
    // 3. Explicitly release the lock
    drop(guard);
  }
});
```

### 2. RwLock (Read-Write Lock)

A `RwLock` is optimized for scenarios where data is read often but written rarely. It allows **multiple** simultaneous readers but only **one** writer.

```
import { spawn, move, RwLock } from "multithreading";

const lock = new RwLock(new Int32Array(new SharedArrayBuffer(4)));

// Spawning a Writer
spawn(move(lock), async (l) => {
  // Blocks until all readers are finished (asynchronously)
  using guard = await l.write();
  guard.value[0] = 42;
});

// Spawning Readers
spawn(move(lock), async (l) => {
  // Multiple threads can hold this lock simultaneously
  using guard = await l.read();
  console.log(guard.value[0]);
});
```

### 3. Semaphore

A `Semaphore` limits the number of threads that can access a resource simultaneously. Unlike a Mutex (which allows exactly 1 owner), a Semaphore allows `N` owners. This is essential for rate limiting, managing connection pools, or bounding concurrency.

```
import { spawn, move, Semaphore } from "multithreading";

// Initialize with 3 permits (allowing 3 concurrent tasks)
const semaphore = new Semaphore(3);

for (let i = 0; i < 10; i++) {
  spawn(move(semaphore), async (sem) => {
    console.log("Waiting for slot...");

    // Will wait (async) if 3 threads are already working
    using _ = await sem.acquire();

    console.log("Acquired slot! Working...");

    await new Promise(r => setTimeout(r, 1000));

    // Guard is disposed automatically, releasing the permit for the next thread
  });
}
```

#### Manual Release

Like the Mutex, if you cannot use the `using` keyword, you can manually manage the lifecycle.

```
spawn(move(semaphore), async (sem) => {
  const { drop } = await import("multithreading");
  // Acquire 2 permits at once
  const guard = await sem.acquire(2);

  try {
    // Critical Section
  } finally {
    // Release the 2 permits
    drop(guard);
  }
});
```

### 4. Condvar (Condition Variable)

A `Condvar` allows threads to wait for a specific condition to become true. It saves CPU resources by putting the task to sleep until it is notified, rather than constantly checking a value.

```
import { spawn, move, Mutex, Condvar } from "multithreading";

const mutex = new Mutex(new Int32Array(new SharedArrayBuffer(4)));
const cv = new Condvar();

spawn(move(mutex, cv), async (lock, cond) => {
  using guard = await lock.acquire();

  // Wait until value is not 0
  while (guard.value[0] === 0) {
    // wait() unlocks the mutex, waits for notification, then re-locks.
    await cond.wait(guard);
  }

  console.log("Received signal, value is:", guard.value[0]);
});
```

---

## Channels (MPMC)

For higher-level communication, this library provides a **Multi-Producer, Multi-Consumer (MPMC)** bounded channel. This primitive mimics Rust's `std::sync::mpsc` but allows for multiple consumers. It acts as a thread-safe queue that handles backpressure, blocking receivers when empty and blocking senders when full.

Channels are the preferred way to coordinate complex workflows (like job queues or pipelines) between workers without manually managing locks.

### Key Features

* **Arbitrary JSON Data:** Channels are backed by `SharedJsonBuffer`, allowing you to send any JSON-serializable value (objects, arrays, strings, numbers, booleans) through the channel, not just raw integers.
* **Bounded:** You define a capacity. If the channel is full, `send()` waits. If empty, `recv()` waits.
* **Clonable:** Both `Sender` and `Receiver` can be cloned and moved to different workers.
* **Reference Counted:** The channel automatically closes when all Senders are dropped (indicating no more data will arrive) or all Receivers are dropped.

### Example: Worker Pipeline with Objects

```
import { spawn, move, channel } from "multithreading";

// Create a channel that holds objects
const [tx, rx] = channel<{ hello: string }>();

// Producer Thread
spawn(move(tx), async (sender) => {
  await sender.send({ hello: "world" });
  await sender.send({ hello: "multithreading" });
  // Sender is destroyed here, automatically closing the channel
});

// Consumer Thread
spawn(move(rx.clone()), async (rx) => {
  for await (const value of rx) {
    console.log(value); // { hello: "world" }
  }
});

// Because we cloned rx, we can also receive on the main thread
for await (const value of rx) {
  console.log(value); // { hello: "world" }
}
```

## Importing Modules in Workers

One of the most difficult aspects of Web Workers is handling imports. This library handles this automatically, enabling you to use dynamic `await import()` calls inside your spawned functions.

You can import:

1. **External Libraries:** Packages from npm/CDN (depending on environment).
2. **Relative Files:** Files relative to the file calling `spawn`.

**Note:** The function passed to `spawn` must be self-contained or explicitly import what it needs. It cannot access variables from the outer scope unless they are passed via `move()`.

### Example: Importing Relative Files and External Libraries

Assume you have a file structure:

* `main.ts`
* `utils.ts` (contains `export const magicNumber = 42;`)

```
// main.ts
import { spawn } from "multithreading";

spawn(async () => {
  // 1. Importing a relative file
  // This path is relative to 'main.ts' (the caller location)
  const utils = await import("./utils.ts");
  // 2. Importing an external library (e.g., from a URL or node_modules resolution)
  const _ = await import("lodash");

  console.log("Magic number from relative file:", utils.magicNumber);
  console.log("Random number via lodash:", _.default.random(1, 100));

  return utils.magicNumber;
});
```

---

## API Reference

### Runtime

* **`spawn(fn)`**: Runs a function in a worker.
* **`spawn(move(arg1, arg2, ...), fn)`**: Runs a function in a worker with specific arguments transferred or copied.
* **`initRuntime(config)`**: Initializes the thread pool (optional, lazy loaded by default).
* **`shutdown()`**: Terminates all workers in the pool.

### Memory Management

* **`move(...args)`**: Marks arguments for transfer (ownership move) rather than structured clone. Accepts a variable number of arguments which map to the arguments of the worker function.
* **`drop(resource)`**: Explicitly disposes of a resource (calls `[Symbol.dispose]`). This is required for manual lock management in environments like Bun.
* **`SharedJsonBuffer`**: A class for storing JSON objects in shared memory.

### Channels (MPMC)

* **`channel<T>(capacity)`**: Creates a new channel. Returns `[Sender<T>, Receiver<T>]`.
* **`Sender<T>`**:
  + `send(value)`: Async. Returns `Promise<Result<void, Error>>`.
  + `sendSync(value)`: Blocking. Returns `Result<void, Error>`.
  + `clone()`: Creates a new handle to the same channel (increments ref count).
  + `close()`: Manually closes the channel for everyone.
* **`Receiver<T>`**:
  + `recv()`: Async. Returns `Promise<Result<T, Error>>`.
  + `recvSync()`: Blocking. Returns `Result<T, Error>`.
  + `clone()`: Creates a new handle to the same channel.
  + `close()`: Manually drops this handle.

### Synchronization

* **`Mutex<T>`**:
  + `acquire()`: Async lock (Recommended). Returns `Promise<MutexGuard>`.
  + `tryLock()`: Non-blocking attempt. Returns boolean.
  + `acquireSync()`: Blocking lock (Halts Worker). Returns `MutexGuard`.
* **`RwLock<T>`**:
  + `read()`: Async shared read access (Recommended).
  + `write()`: Async exclusive write access (Recommended).
  + `readSync()` / `writeSync()`: Synchronous/Blocking variants.
* **`Semaphore`**:
  + `acquire(amount?)`: Async wait for `n` permits. Returns `SemaphoreGuard`.
  + `tryAcquire(amount?)`: Non-blocking. Returns `SemaphoreGuard` or `null`.
  + `acquireSync(amount?)`: Blocking wait. Returns `SemaphoreGuard`.
* **`Condvar`**:
  + `wait(guard)`: Async wait (Recommended). Yields execution.
  + `notifyOne()`: Wake one waiting thread.
  + `notifyAll()`: Wake all waiting threads.
  + `waitSync(guard)`: Blocking wait (Halts Worker).

---

## Technical Implementation Details

For advanced users interested in the internal mechanics:

* **Serialization Protocol**: The library uses a custom "Envelope" protocol (`PayloadType.RAW` vs `PayloadType.LIB`). This allows complex objects like `Mutex` handles to be serialized, sent to a worker, and rehydrated into a functional object connected to the same `SharedArrayBuffer` on the other side.
* **Atomics**: Synchronization is built on `Int32Array` backed by `SharedArrayBuffer` using `Atomics.wait` and `Atomics.notify`.
* **Import Patching**: The `spawn` function analyzes the stack trace to determine the caller's file path. It then regex-patches `import()` statements within the worker code string to ensure relative paths resolve correctly against the caller's location, rather than the worker's location.

## About

The missing standard library for multithreading in JavaScript (Works in Node.js, Deno, Bun, Web browser)

### Topics

[nodejs](/topics/nodejs "Topic: nodejs")
[javascript](/topics/javascript "Topic: javascript")
[multi-threading](/topics/multi-threading "Topic: multi-threading")
[typescript](/topics/typescript "Topic: typescript")
[concurrency](/topics/concurrency "Topic: concurrency")
[web-worker](/topics/web-worker "Topic: web-worker")
[multithreading](/topics/multithreading "Topic: multithreading")
[threads](/topics/threads "Topic: threads")
[parallel-processing](/topics/parallel-processing "Topic: parallel-processing")
[es6-generators](/topics/es6-generators "Topic: es6-generators")
[worker-pool](/topics/worker-pool "Topic: worker-pool")
[shared-worker](/topics/shared-worker "Topic: shared-worker")
[webworkers](/topics/webworkers "Topic: webworkers")
[worker-threads](/topics/worker-threads "Topic: worker-threads")
[web-workers](/topics/web-workers "Topic: web-workers")

### Resources

[Readme](#readme-ov-file)

### License

[MIT license](#MIT-1-ov-file)

### Uh oh!

There was an error while loading. Please reload this page.

[Activity](/W4G1/multithreading/activity)

### Stars

[**567**
stars](/W4G1/multithreading/stargazers)

### Watchers

[**5**
watching](/W4G1/multithreading/watchers)

### Forks

[**12**
forks](/W4G1/multithreading/forks)

[Report repository](/contact/report-content?content_url=https%3A%2F%2Fgithub.com%2FW4G1%2Fmultithreading&report=W4G1+%28user%29)

## [Releases](/W4G1/multithreading/releases)

[16
tags](/W4G1/multithreading/tags)

## [Packages 0](/users/W4G1/packages?repo_name=multithreading)

No packages published

### Uh oh!

There was an error while loading. Please reload this page.

## Languages

* [TypeScript
  100.0%](/W4G1/multithreading/search?l=typescript)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Community](https://github.community/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.
